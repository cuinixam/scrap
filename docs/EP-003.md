# EP-003: Support for `.conda` Archives

| Status | Draft |
| :--- | :--- |
| **Author** | User |
| **Created** | 2026-02-14 |
| **Updated** | 2026-02-14 |

## Abstract

This proposal adds support for the `.conda` archive format to Poks. The `.conda` format is a two-level archive (an outer zip containing inner `.tar.zst` packages) used by the conda ecosystem. Poks will extract the package contents and **poke** them into shape — rewriting hardcoded prefixes so conda packages work outside a conda environment without requiring the full conda toolchain as a dependency.

## Motivation

Many pre-built binary tools are distributed exclusively (or most conveniently) as conda packages via channels like `conda-forge`. Currently, Poks users cannot leverage these packages without installing conda itself. Adding `.conda` support opens access to conda-forge's extensive catalog of pre-built binaries for all platforms.

However, conda packages are built against a known install prefix (e.g., `/opt/conda`). Binary files, scripts, and configuration often contain hardcoded references to this prefix. Simply extracting the archive is not enough — the extracted files must be **patched** to replace the build prefix with the actual install location. We call this process **poking** (i.e., poking the package into shape for its new home).

## Background: The `.conda` Format

A `.conda` file is a standard **zip** archive with the following internal structure:

```
package-1.0-h1234_0.conda
├── metadata.json                              # top-level metadata (format version)
├── pkg-package-1.0-h1234_0.tar.zst           # the actual package contents
└── info-package-1.0-h1234_0.tar.zst          # conda metadata (paths.json, index.json, etc.)
```

- The **outer** container is a plain zip file (already supported by Poks)
- The **inner** archives use **Zstandard** (`.tar.zst`) compression — not supported by Python's stdlib `tarfile` module
- `pkg-*.tar.zst` contains the installable files (binaries, libraries, scripts, etc.)
- `info-*.tar.zst` contains conda-specific metadata, importantly `paths.json` which describes which files contain hardcoded prefixes and how to patch them

### `info/paths.json`

The `paths.json` file inside the info archive describes every file in the package. Entries that require prefix replacement look like:

```json
{
  "_path": "bin/tool",
  "path_type": "hardlink",
  "prefix_placeholder": "/opt/conda",
  "file_mode": "text"
}
```

- `prefix_placeholder`: the build-time prefix baked into the file — conda-build uses a deliberately long placeholder (up to **255 characters**, e.g., `/opt/anaconda1anaconda2anaconda3/placeholder_placeholder_...`) so that virtually any real install path fits within the reserved space
- `file_mode`: either `"text"` (simple string replacement) or `"binary"` (null-padded replacement to preserve file offsets)

## Specification

### 1. New Archive Format: `".conda"`

Add `".conda": "conda"` to `SUPPORTED_FORMATS` in `extractor.py`.

### 2. New Dependency: `zstandard`

Add the [`zstandard`](https://pypi.org/project/zstandard/) package as a core dependency. This is a well-maintained, widely-used Python binding for the Zstandard compression library. It is required because Python's `tarfile` does not support `.tar.zst` natively (stdlib support is not expected until Python 3.14+, and Poks targets 3.10+).

### 3. Two-Level Extraction

The `.conda` format requires a dedicated extraction path since it does not fit the single-level `(open, extract_all)` pattern used by other formats:

1. Open the outer `.conda` zip
2. Locate and extract `info-*.tar.zst` — parse `paths.json` from it
3. Locate and extract `pkg-*.tar.zst` contents into `dest_dir`
4. Apply **poking** (prefix patching) to the extracted files
5. Discard the info archive contents (they are not needed at runtime)

Path traversal validation must be applied to the inner tar archive entries, just as with other formats.

### 4. Poking: Prefix Patching

**Poking** is the post-extraction step that rewrites hardcoded conda build prefixes to the actual Poks install directory (`~/.poks/apps/<name>/<version>/`).

The patching logic is driven by `paths.json` entries that have a `prefix_placeholder` field. Since conda-build uses a long placeholder (~255 chars), the typical Poks install path (~40-60 chars) will always fit within the reserved space.

#### Text Mode (`file_mode: "text"`)

Simple string replacement — all occurrences of `prefix_placeholder` are replaced with the actual install path:

```
old: #!/opt/anaconda1anaconda2anaconda3/.../bin/python
new: #!/home/user/.poks/apps/cmake/3.28.1/bin/python
```

#### Binary Mode (`file_mode: "binary"`)

Null-padded replacement to preserve byte offsets in compiled binaries. The placeholder occupies a fixed-size region in the binary; the new prefix is written in place and padded with `\0` bytes to fill the remaining space:

```
offset 0x4000: /opt/anaconda1anaconda2anaconda3/...\0  (255 bytes reserved)
offset 0x4000: /home/user/.poks/apps/cmake/3.28.1\0\0\0\0\0...  (same 255 bytes)
```

If the new prefix is longer than the placeholder (extremely unlikely given the ~255 char budget), poking must fail with a clear error.

#### Windows Path Handling

On Windows, conda placeholders may use either `\` or `/` as the path delimiter. The poking logic must:

1. Detect the delimiter used in the placeholder
2. Use the matching delimiter in the replacement path
3. Handle both forward and backslash variants when both appear in the same file

#### Implementation

A new module `src/poks/poker.py` will handle the poking logic:

```python
@dataclass
class PatchEntry:
    path: str
    prefix_placeholder: str
    file_mode: str  # "text" or "binary"

def poke(install_dir: Path, patches: list[PatchEntry]) -> None:
    """Poke conda package files into shape by replacing build prefixes."""
    ...
```

### 5. Manifest Usage

No changes are needed to the domain models. The existing `PoksArchive.ext` field already supports arbitrary extensions:

```json
{
  "description": "CMake",
  "versions": [
    {
      "version": "3.28.1",
      "url": "https://conda.anaconda.org/conda-forge/linux-64/cmake-${version}-h..._0.conda",
      "archives": [
        {
          "os": "linux",
          "arch": "x86_64",
          "ext": ".conda",
          "sha256": "abc123..."
        },
        {
          "os": "macos",
          "arch": "aarch64",
          "ext": ".conda",
          "sha256": "def456..."
        }
      ],
      "bin": ["bin"]
    }
  ]
}
```

Note that conda channel URLs use their own platform subdirectories (e.g., `linux-64`, `osx-arm64`, `win-64`) which do not match Poks' `${os}`/`${arch}` variables. For conda packages, manifest authors should use archive-level `url` fields with hardcoded platform paths, or the version-level `url` can use Poks variables if a custom `${conda_subdir}` variable is added (see Open Questions).

### 6. Integration in the Install Flow

The install flow in `poks.py` changes minimally. `extract_archive` already handles format detection internally. The only new step is that for `.conda` archives, extraction includes the poking phase. This can be handled transparently inside `extractor.py` so that the orchestrator remains unaware of the conda-specific logic.

Alternatively, `extract_archive` could return metadata indicating that poking is needed, and the orchestrator would invoke `poke()` as a separate step. This keeps extraction and patching as distinct concerns.

**Recommended approach**: Keep poking inside the extraction step for `.conda` files. The orchestrator should not need to know whether a package came from conda or not — the result is the same: a directory of ready-to-use files.

## Implementation Plan

| Step | Module | Description |
|------|--------|-------------|
| 1 | `pyproject.toml` | Add `zstandard` dependency |
| 2 | `poker.py` (new) | Implement `PatchEntry` model and `poke()` function for text-mode and binary-mode prefix replacement, including Windows path delimiter handling |
| 3 | `extractor.py` | Add `".conda"` format; implement `_extract_conda()` for two-level extraction + poking |
| 4 | `tests/helpers.py` | Add `_create_conda()` helper to build test `.conda` archives |
| 5 | `tests/` | Add tests for: conda extraction, text poking, binary poking, Windows delimiter handling, prefix-too-long error, path traversal in inner tar |
| 6 | `docs/specs.md` | Update specification to document `.conda` support and the poking concept |

## Security Considerations

- Path traversal validation is applied to inner `.tar.zst` entries, same as other formats
- SHA256 verification of the downloaded `.conda` file happens before extraction (existing behavior)

## Open Questions

1. **`${conda_subdir}` variable**: Should a new template variable be added to `resolver.py` that maps Poks platform pairs to conda subdirectory names (e.g., `linux`+`x86_64` → `linux-64`, `macos`+`aarch64` → `osx-arm64`)? This would make conda URL templates more ergonomic. Alternatively, manifest authors can use per-archive `url` fields.

2. **Missing `paths.json`**: If a `.conda` file lacks `paths.json` (rare but possible for very simple packages), should Poks skip poking silently or warn the user?

3. **`.tar.bz2` conda packages**: The older conda format uses `.tar.bz2` instead of `.conda`. These are already extractable by Poks (`.tar.bz2` is supported), but they lack the two-level structure and may still need poking. Should this be addressed in this EP or deferred?

## Future Work

- **`.tar.bz2` conda packages**: The older conda format may also benefit from poking support (see Open Questions).
